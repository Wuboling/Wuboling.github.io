---
layout:     post                    # 使用的布局（不需要改）
title:      操作系统                  # 标题
subtitle:                           #副标题
date:       2020-10-22              # 时间
author:     wbl                     # 作者
header-img: img/post_green.jpg    #这篇文章标题背景图片
catalog: true                       # 是否归档
tags:                               #标签
    - 操作系统
---
### 操作系统
 - 操作系统介绍
 - 进程和线程
 - 内存管理
 - 文件管理（todo）
 - I/O 管理（todo）

---


## 一、操作系统介绍

**操作系统**：控制和管理整个计算机系统的软件和硬件资源，并合理地组织调度计算机的工作和资源的分配；提供给用户和其他软件方便的接口和环境；它是计算机系统中最基本的系统软件。

**作用**：计算机系统的由处理器、主存、打印机、键盘、鼠标、显示器、网络接口以及各种输入输出设备等硬件构成。**在计算机系统上安装操作系统，操作系统能够通过响应用户输入的指令达到控制硬件的效果。**用户不用直接对硬件进行操作，只需要输入操作系统的相关指令。

![img](https://mmbiz.qpic.cn/mmbiz_png/libYRuvULTdWiaexJhvU13C7OJUrpibcRL5qxtz1fZXfcQrkMViclryH8H2bichd7gR7LIK5W6xK9eHHYIpO467yf3g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

#### 功能

- 作为系统资源的管理者
  - 文件管理（根据路径找到可执行文件，打开QQ.exe）
  - 存储器管理（将该程序的相关数据放入内存）
  - 处理机管理（对应的进程CPU执行）
  - 设备管理（将摄像头分配给进程）
- 作为用户和计算机硬件之间的接口
  - 命令接口
  - 程序接口/系统调用（.dll文件）
  - GUI（图形用户界面）
- 计算机系统中最基本的系统软件
  - 实现对硬件机器的拓展

#### 特征

- 并发：指两个或多个事件在同一时间间隔内发生。这些事件宏观上是同时发生的，但微观上是交替进行的。（并行：指两个或多个事件在同一时刻同时发生。）
- 共享：资源共享，指操作系统中的资源可供内存中多个并发执行的进程共同使用。
  - 互斥共享（同一时刻只能有一个进程访问；QQ和微信同时请求摄像头资源，有先后顺序）
  - 同时共享（允许一个时间段内多个进程“同时”对他们进行访问；扬声器边播放音乐边输出游戏的声音）
- 虚拟：把物理上（实际存在的）的实体变为若干逻辑上的对应物（用户感受的）。
- 异步：在多道程序环境下，允许多个程序并发执行，但系统资源有限，进程的执行不是一贯到底，而是走走停停，以不可预知的进度向前推进，这就是进程的并发性。

并发和共享互为存在条件，没有并发和共享，就谈不上虚拟和异步。

#### 运行机制

- 两种指令：特权指令、非特权指令
- 两种处理器状态：核心态、用户态
- 两种程序：内核程序、应用程序

特权指令和内核程序只能在核心态下执行

#### 体系结构

截图

#### 中断和异常

todo

#### 系统调用

- 触发条件：与资源有关、会直接影响到其他进程的操作
- 分类：
  - 设备管理
  - 文件管理
  - 进程控制
  - 进程通信
  - 内存管理

- 底层执行过程
  - 汇编语言传递系统调用参数、执行陷入指令（trap等，用户态进行）、执行系统调用相应服务程序（核心态进行）、返回用户程序

## 二、进程和线程

### 进程

程序段、数据段、PCB组成了进程实体，简称进程。

**所谓创建、删除进程，指的是PCB（系统为每个运行的程序配置的一个数据结构，称为进程控制块，用来描述进程的各种信息，如程序代码存放位置、PID、UID等）**

- 进程的组成

  截图

- 进程的状态（截图）

  - 运行态：占有CPU，并且在运行
  - 就绪态：已具备运行条件，但没有空闲的CPU，暂时不能运行
  - 阻塞态：因等待某一事件而暂时不能运行
  - 创建态：进程正在被创建，操作系统为进程分配资源，初始化PCB
  - 终止态：进程从系统中撤销，操作系统收回进程所拥有的资源、撤销PCB

#### 进程通信

- 进程通信是进程间的信息交换，进程是系统分配资源的单位（包括内存空间地址），因此各进程拥有的内存地址空间相互独立

- 方式
  - 共享存储
    - 两个进程对共享空间的访问必须互斥（不能同时）
  - 消息传递（消息队列）
  - 管道通信
    - 管道通信为半双工通信方式

### 线程

线程是一个基本的CPU执行单元，也是程序执行流的最小单位

- 属性
  - 线程是处理机调度的单位
  - 多CPU计算机中，各个线程可占用不同的CPU
  - 每个线程都有一个线程ID、线程控制块（TCB）
  - 线程也有就绪、阻塞、运行三种基本状态
  - 线程几乎不拥有系统资源
  - 同一进程的不同线程间共享进程的资源
  - 由于线程共享内存地址空间，同一进程中的线程间通信甚至无需操作系统干预

### 处理机调度

在多道程序系统中，进程数量多于处理机个数时，需要处理机决定进程先后执行顺序。

**处理机调度**: 从就绪队列中按照一定的算法选择一个进程并将处理机分配给他运行，以实现进程的并发执行

#### 三层调度

- 高级调度
  - 按照某种规则，从后备队列中选择合适的作业将其调入内存，并为其创建进程
  - 特点：从外存到内存；从无到创建进程再到就绪态
- 中级调度
  - 从挂起队列中选择合适的进程将其数据调回内存
  - 特点：外存到内存；从挂起态到就绪态
  - 作用：内存中不具备运行条件的进程（就绪态、阻塞态），将其挂起，通过内存映射调度到磁盘中的挂起队列中，或将其从挂起队列中选择合适的进程将其数据调回内存，提高内存的利用率。
- 低级调度（进程调度）
  - 从就绪队列中选择一个进程为其分配处理机
  - 特点：从内存到CPU；就绪态到运行态
  - 作用：提高并发性

#### 进程调度方式

- 非剥夺调度方式
  - 只允许进程主动放弃处理机。即一旦开启，直到进程终止或主动要求进入阻塞态
- 剥夺调度方式
  - 运行中的进程遇到更加紧迫的进程需要使用处理机时，立即停止正在执行的进程，并将处理机分配给更加重要的进程。

**进程切换的过程：**

- 对原来运行的进程各种数据的保存
- 对新的进程各种数据的恢复

***注意***: 频繁的进程切换降低系统工作效率，因为太多时间花在进程切换，少部分时间花在进程执行



### 调度算法

- 调度算法评价指标
  - CPU利用率
  - 系统吞吐量
  - 周转时间：从作业被提交给系统开始到做业务完成为止的时间间隔
  - 等待时间：作业或进程等待处理机状态时间之和
  - 响应时间：用户从提出请求CPU到得到响应的时间
- **调度算法类型**（截图---）
  - 批处理系统
    - 先来先服务（FCFS）
    - 短作业优先（SJF）
    - 高响应比优先（HRRN）
      - （等待时间 + 服务时间）/等待时间
  - 交互式系统
    - 时间片轮转（RR，每个进程的处理机处理时间一定）
    - 优先级调度算法
    - 多级反馈队列算法（集合先来先服务，时间片轮转和优先级调度算法）

#### 进程同步、互斥

- 进程同步

  - 某些进程的执行需要明确的先后顺序，但并发性带来异步性，因此需要通过进程同步来解决进程异步的问题。

- 进程互斥

  - 对临界资源的访问，需要互斥进行。即同一时间段内只能允许一个进程访问资源
  - 实现方法（todo）

- 信号量机制

  - 作用：操作系统利用原语控制信号量，实现进程的互斥、同步

  - 分类

    - 整型信号量：用整数型的变量作为信号量，表示系统资源的数量

      ```c
      int S = 1; //初始化整数型变量，表示系统的打印机数量为1
      
      void wait(int S) //wait 原语，相当于“进入区”，P操作
      {	
          while (S<=0); //如果系统资源不够，就一直循环等待
          S = S - 1;    //如果资源数够，则占用一个资源
      }
      
      void 临界区（执行打印操作过程）
      
      void signal(int S) // signal原语，相当于“退出区”，V操作
      {
          S = S + 1;    //使用资源后，释放资源
      }
      
      
      若存在两个进程同时请求打印机资源
      
      进程p0：
      ...
      wait(s);
      使用打印机资源...
      signal(s)
      
      进程p1：
      ...
      wait(s);
      使用打印机资源...
      signal(s)
      
      but此时打印机资源被p0占有，p1只能进入等待状态
      ```

    - 记录型信号量：为了解决整数型信号量出现“忙等”状态，引入记录型信号量，通过资源数决定唤醒阻塞队列进程的死机。

      ```c#
      /*记录型信号的定义*/
      typedef struct{
          int vaule =1;  //资源数量
          struct process *L; //等待队列    
      }semaphore;
      
      void wait(semaphore){
          s.value--;     
          if (s.value < 0){
              block(s.L);  // 当系统资源短缺时，block进程到阻塞队列中
          }
      }
      
      void signal(semaphore){
          s.value++;      //使用完资源后，释放资源
          if (s.value <=0){
              wakeup(s.l)  //当阻塞队列中还有进程时，唤醒进程
          }
      }
      
      若存在两个进程同时请求打印机资源
      
      进程p0：
      ...
      wait(s);   //申请系统资源
      使用打印机资源...
      signal(s)  //释放系统资源
          
      
      进程p1：
      ...
      wait(s);
      使用打印机资源...
      signal(s)
          
      分析过程：
      此时p0执行wait（s）进程占用打印机的资源，value的值为0，此时p1申请打印机资源，执行wait（s）,value = value-1 = -1, p1进程加入阻塞队列，当p0使用完资源，执行signal（s），value = 0,唤醒阻塞队列中的p1进程。
      ```

  - 记录型和整数型信号量的比较

    - 当系统资源出现短缺时，整数型信号量机制的进程会不断测试系统资源是否足够，处于“忙等“状态；而记数型信号量会通过阻塞队列存放阻塞的进程，在每个进程结束使用资源时，判断剩余的系统资源的大小，从而决定是否应该唤醒阻塞队列中的进程。

  - 信号量机制实现互斥、同步

    - 实现互斥：
      - 设置信号量为系统资源的值
      - 临界区前执行P操作
      - 临界区之后执行V操作
    - 实现同步：
      - 定位需要实现同步的地方，保证一前一后的操作
      - 设置信号量S，初始值为0
      - 在”前操作“之后执行V（S）
      - 在”后操作“之前执行P（S）
    - 实现前驱关系（即多个进程实现同步操作，参考实现同步）

- 互斥、同步的问题

  - 生产者-消费者问题

    - 系统中有一组生产者进程和消费者进程，生产者进程每次生产一个产品放入缓冲区，消费者进程每次从缓冲区中取出一个产品并使用（”产品“理解为某种数据）

      - 生产者和消费者共享一个初始为空、大小为n的缓冲区。（不同生产者互斥放入产品）
      - 只有缓冲区未满，生产者才能往缓冲区中添加产品
      - 只有缓冲区不为空，消费者才能往缓冲区取出产品

      ```c#
      semaphore mutex =1;   //互斥信号量，实现对缓冲区的互斥访问
      semaphore empty =0;   //同步信号量，表示空闲缓冲区的数量
      semaphore full  =n;	  //同步信号量，表示产品的数量
      
      
      producer(){
          while(1){
              生产一个产品;
          	P（empty）; //消耗一个空闲缓冲区
          	P(mutex);  // 实现互斥是在进程中进行一对PV操作
          	把产品放入缓冲区;
          	V（mutex）; 
          	V(full); // 增加一个产品
          }
      }
      
      consumer(){
          while(1){
              P(full); // 消耗一个产品
              P(mutex);
              从缓冲区取出一个产品;
              V（mutex);
              V(empty); //增加一个空闲缓冲区
              使用产品；
          }
      }
      
      注意：实现互斥是在进程中进行一对P V操作；实现两进程的同步是在一个进程中执行P操作，一个进程执行V操作；生产者-消费者的互斥进程必须在同步进程之后，否则出现死锁。
      ```

    - 多生产者-多消费者

      - 不同生产者生产不同类型产品；不同消费者消费不同产品类型（分析参照生产者-消费者模型）

    - 吸烟者问题

      - 一供应商向吸烟者轮流提供三种不同类型的制烟材料，每次只能提供一种，三个吸烟者需要三种不同类型的制烟材料

        ```c#
        semaphore offer1 = 0; //桌子上材料一
        semaphore offer2 = 0; //桌子上材料二
        semaphore offer3 = 0; //桌子上材料三
        int i = 0;			  //实现轮流提供
        
        provider(){
            while(1)
            if（i==0）{
                将材料一放桌子上；
                V（offer1);
            }else if(i==1){
                将材料二放桌子上；
            }else if（i==2）{
                将材料三放在桌子上；
                V（offer3）
            }
            i = （i+1）% 3;
            P（finish);
        }
        
        smoker1(){
            while(1){
                P(offer1);
                从桌子上拿走材料一；用掉;
                V（finish);
            }
        }
        
        smoker2(){
            while(1){
                P(offer2);
                从桌子上拿走材料二；用掉;
                V（finish);
            }
        }
        
        smoker3(){
            while(1){
                P(offer3);
                从桌子上拿走材料三；用掉;
                V（finish);
            }
        }
        ```

        - 写者、读者问题

          - 允许多个进程同时对数据进行读操作，但是不允许读和写以及写和写操作同时发生。

        - 哲学家进餐问题

          - 五个哲学家围着一张圆桌，每个哲学家面前放着食物。哲学家的生活有两种交替活动：吃饭以及思考。当一个哲学家吃饭时，需要先拿起自己左右两边的两根筷子，并且一次只能拿起一根筷子。

            ```c#
            semaphore chopstick[5] = [1,1,1,1,1]; //给无根筷子编号，存进数组中
            semaphore mutex = 1;                  //互斥地取筷子
            Pi(){                                 //i号哲学家的进程
            	while(1){
                    P(mutex);
                    P(chopstick[i]); //拿左
                    P(chopstick[(i+1)%5]); //拿右
                    V（metux）;
                    吃饭...
                    V(chopstick[i]); //放左 
                    V(chopstick[(i+1)%5]); //放右
                    思考...
                }
            }
            ```

- 管程

  - 使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。管程可类比为类，只需要调用类中的插入和删除函数即可。
  - 管程中设置变量和等待/唤醒操作，解决同步问题
  - 由编译器实现各进程互斥地进入管程中的过程（每次只允许一个线程调用管程内的“函数”）	

#### 死锁

死锁：各进程互相等待对方进程手里的资源，导致各进程都阻塞，无法向前推进的想象

饥饿：由于长期得不到想要的资源，某进程无法向前推进

死循环：进程执行过程中一直跳不出某个循环的想象，代码逻辑错误



##### 产生死锁的必要条件

产生死锁必须同时满足以下四个条件，破坏任何一个条件，死锁不会发生

- 互斥条件：对必须互斥使用的资源的争夺
- 不剥夺条件：进程所获得的资源在未使用完之前，其他进程不能强行抢夺该资源
- 请求和保护条件：进程已经至少保持一个资源，但又提出新的资源请求，而新资源被其他进程占有，造成进程阻塞，但又不释放现有的资源
- 循环等待条件：存在进程资源等待的循环等待链，链中每个进程已获得的资源同时被下一个进程所请求



##### 什么情况发生死锁

对不可剥夺资源的不合理分配，可能导致死锁

- 对系统（不可剥夺）资源的竞争
- 进程推进顺序非法（请求和释放资源的顺序不当）
- 信号量使用不当（如生产-消费者问题，互斥P操作在同步P操作之前会导致死锁）



#### 死锁的处理策略

- 预防死锁

- 避免死锁
- 死锁的检测和解除

##### 预防死锁

破坏死锁的四个必要条件中的一个

- 破坏互斥条件：使用SPOOLing技术将独占设备改为共享设备
- 破坏不剥夺条件：当某个进程请求新的资源被其他进程占有，它必须立即释放所保持的所有资源，待以后需要的时候再重新申请
- 破坏请求和保持条件：进程运行前一次性申请完所需要的全部资源，一旦投入使用，其他进程不能使用
- 破坏循环等待条件：首先给系统资源编号，规定每个进程必须按编号递增顺序请求资源，同编号资源一次性申请完

##### 避免死锁

银行家算法找到安全序列

- 检查此次申请是否超过之前声明的最大需求数
- 检查此时系统剩余的可用资源是否还能满足这次请求
- 试探着分配，更改各数据结构
- 用安全型算法检查此分配是否会导致系统进入不安全状态

##### 死锁检测和解除

不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复。

##### 1.检测（截图）

如果资源分配图，最终能消除所有边，则不会发生死锁。最终还连着边的进程表示发生死锁。

##### 2.解除

- 抢占死锁的进程的系统资源给其他进程使用
- 回滚进程的资源，直到避免死锁的状态
- 杀死进程



## 三、内存管理

### 1、内存、存储单元

内存：内存是用于存放数据的硬件，程序运行前需要先放到内存中才能被CPU处理

存储单元：内存由一个个”小房间“组成，”小房间“为存储单元。内存地址从0开始，每个地址对应一个存储单元。若计算机”按字节编址“，每个存储单元大小为1Byte。若字长16位，"按字编址"，则每个存储单元大小为一个字。

### 2.逻辑地址和物理地址

逻辑地址：是指用户程序经编译后，每个目标模块以0为基地址进行的顺序编址。逻辑地址又称相对地址 。

物理地址：是指内存中各物理存储单元的地址从统一的基地址进行的顺序编址



**写程序到运行的过程**：程序编写（源代码）、编译（将源码编译成若干目标模块，利用逻辑地址进行编址）、连接（将目标模块串起来，形成装入模块，装入模块具有完整的逻辑地址）、装入（将装入模块装入内存，内存中的模块利用物理地址进行编址）

**装入的三种方法**：

- 绝对装入：在编译时，如果知道程序将放到内存中的具体位置，编译程序将产生绝对地址的目标代码。装入程序按照装入模块中的地址，将程序和数据装入内存。
  - 特点：（只适用于单道程序）
- 静态重定位（可重定位装入）：编译链接后的装入模块的逻辑地址都是从0开始，可根据内存当前情况，将装入模块装入内存适当位置（此时知道初始的物理地址值A），装入时，对地址进行”重定位“（逻辑地址+初始的物理地址A），实现从逻辑地址到物理地址的转换。
  - 特点：（必须分配装入的全部空间，空间不够不装入，装入后运行期间不能移动）
- **动态重定位：**编译链接后的装入模块的逻辑地址都是从0开始。装入模块装入内存后并不会及时转为物理地址，而是当程序真正运行时才转换。重定位寄存器存放装入模块的起始物理地址，转换时，将起始物理地址+逻辑地址即可
  - 特点：可更改重定位寄存器的值，实现程序在内存中位置更改；程序可以分配到不连续的存储区；程序运行期间，根据需要分配内存

**链接三种方法**

- 静态链接：在程序运行前，现将各个目标模块及它们所需的库函数链接成一个完整的可执行文件（装入模块）
- 装入时动态链接：将各个模块装入内存时，边装入边链接
- 运行时动态连接：运行时，根据需要用到的装入模块进行链接。



### 3.内存管理做什么事情

**a.内存空间的分配与回收**

**b.对内存空间进行扩充**

**c.逻辑地址与物理地址的转换**

**d.内存保护**



#### a、内存空间的分配与回收

##### 连续分配管理方式

连续分配：为用户进程分配的必须是一个连续的内存空间

内部碎片：分配给某个进程的内存空间，如果该进程没能把分配的内存空间用满

外部碎片：未分配给任何进程的空闲分区由于太小，其他进程无法使用

- **单一连续分配**

  思想：内存被分为系统区和用户区，系统区通常位于内存地址的低地址部分，存放操作系统的相关数据；用户区存放用户进程的相关数据。内存中只能有一道用户程序，用户程序独占整个用户区空间

  优点：实现简单；无外部碎片；可以采用覆盖技术扩充内存

  缺点：只能用于单用户、但任务的操作系统中；由内部碎片（单个用户进程没把分配的内存用满），存储器利用率低

- **固定分区分配**

  思想： 将用户空间划分为若干固定大小的分区（单个分区的大小固定不变，不同分区大小可不一样），每个分区装入一道作业。

  优点：实现简单，无外部碎片

  缺点：当用户程序太大时，可能所有分区都不能满足，只能利用覆盖技术进行扩充内存；会产生内部碎片

- **动态分区分配**

  思想：不会预先划分内存分区，而是在进程装入内存时，根据进程的大小动态建立分区。

  特点：

  - 可利用空闲分区表或空闲分区链记录内存使用情况。空闲分区表：每个空闲分区对用一个表项，存放分区号、分区大小、分区起始地址等信息
  - 当很多空闲分区满足进程大小时，利用动态分区分配算法确定分区
  - 当回收的内存分区前后都有空闲分区，将回收的分区与空闲分区进行合并

  **动态分区分配算法**

  - 首次适应：从低地址到高地址找合适的分区
  - 邻近适应：由首次适应演变而来，每次查找上次查找结束位置，开始查找
  - 最佳适应：优先使用更小分区，以保留更大分区
  - 最坏适应：优先使用更大分区，以防产生太小的不可利用碎片

##### 非连续分配管理方式

- 分页存储：将内存空间分为一个个大小相等的分区，每个分区就是一个“内存块”；将用户进程的地址空间分为与“内存块”大小相等的一个个区域，称为“页”。操作系统以内存块为单位为各个进程分配内存空间，进程的每个页面分别放入一个页框中， **进程的页面与内存块有一一对应关系**

- 分段存储：按照程序自身逻辑关系划分为若干个段，每个段都有一个段名， 内存一段为单位进行分配，每个段在内存中占据连续空间，但各个段之间可以不相邻。

  

**分页和分段的对比：**

页是信息的物理单位；分页目的为了实现离散分配，提高内存利用率。分页是系统的行为，用户不可见；页的大小固定且由系统决定；分段用户进程地址空间是一维的，只要知道第几号页就能标识具体地址。

段是信息的逻辑单位；分段目的为了更好满足用户需求， 一个段通常包含一组属于一个逻辑块的信息。分段对用户可见，用户变成时需要显示地给出段名；段的长度不固定，决定于用户编写程序。分页地址是二维的，需要知道段名和段内地址才能标识一个地址。

- 段页式存储管理

  先分段再分页

  段号的位数M决定每个进程最多可分多少个段（2<sup>M</sup>个段）

  页号的位数N决定每个段能最多能分多少页（2<sup>N</sup>页）

  页内偏移量位数K决定页面、内存块的大小（2<sup>K</sup>Byte）



#### b、对内存空间进行扩充

当程序的大小比实际内存大小大很多的时候，解决内存太小的问题

 **覆盖技术**（截图）

思想：将内存分一个“固定区”和若干个“覆盖区”，将程序分为多个段，常用的段放在“固定区”，常驻内存，调入后就不掉出，直到运行结束；而不常用的程序段放在“覆盖区”，需要的时候掉入内存，不需要的时候，调出内存

特点：“覆盖区”和“固定区”对用户不透明，由系统自动设置

**交换技术**

思想：内存紧张时，系统将内存中某些进程暂时换出外存中，把外存中某些已具备运行条件的进程换入内存中（进程在内存和磁盘间的动态调度，此时PCB常驻内存）

特点：通常把磁盘分为文件区和对换区，被换出的进程通常存放在对换区；交换通常在许多进程运行且内存吃紧时进行，而系统负荷降低就暂停；可优先换出阻塞进程或优先级低的进程

**虚拟存储技术**

- 目的：为了解决传统存储管理（连续分配、非连续分配的缺点）：一次性（作业必须一次性全部载入后才能运行）和驻留性（一旦被装入内存，就会一直驻留在内存中，直至作业运行结束）

- 局部性原理：

  -  时间局部性（如果程序执行了某条指令，那么不久之后该指令很有可能再次被执行；如果某个数据被执行，不久之后很可能再次被访问，例如，循环）
  -  空间局部性：一旦程序访问了某个存储单元，不久之后，其附近的资源将被访问（例如数组是连续的空间结构）

- 虚拟内存的定义和特征：基于局部性原理，在程序装入时，将很快用到的部分装入到内存，暂时用不到的留在外存，就可以开始执行；执行过程中，当所访问的信息不在内存时，由操作系统将所需的信息载入内存，继续运行；若内存不够，将暂时用不到的信息换出内存，在用户看来似乎有一个比实际内存大得多的内存，这就是虚拟内存

- 虚拟内存的实现：基于离散分配内存的管理方式（请求分页、请求分段、请求段页式存储管理）

- **页面置换算法**

  - **请求分页和基本分页存储管理的主要区别**：执行过程中，当所访问的信息不在内存时，由操作系统将所需的信息载入内存，继续运行；若内存不够，将暂时用不到的信息换出内存, 而页面置换算法决定换出哪一页

  - **算法类型**：

    - 最佳置换算法（OPT）：选择淘汰的页面将是以后永不使用，或者在最长时间内不再被访问的页面，保证最低的却页率。但由于操作系统系统无法预判页面访问的所有序列，因此，此方法无法实现。

    - 先进先出算法（FIFO）：淘汰先进内存的页面。但没考虑页面访问序列，性能差。

    - 最近最久未使用置换算法（LRU）：分页表记录页的使用时间，淘汰最近最久未使用的页面。性能最佳，实现开销大

    - 时钟置换算法（最近未使用算法）：将块组成循环的链表，根据最近是否被访问和最近是否被修改决定置换哪个页面。每个页面都有两个状态位：R 与 M，当页面被访问时设置页面的 R=1，当页面被修改时设置 M=1。其中 R 位会定时被清零。可以将页面分成以下四类：

      - R=0，M=0
      - R=0，M=1
      - R=1，M=0
      - R=1，M=1

      当发生缺页中断时，NRU 算法从链表中挑选一个页面将它换出。

#### c、逻辑地址与物理地址的转换

三种装入方式：绝对装入、可重定位装入、动态运行时装入

#### d、存储保护

目的：保证各进程在自己的内存空间内运行，不会越界访问

方式：

- 设置上下限寄存器，存放进程的上下限地址。进程的指令要访问某个地址时，CPU检查是否越界
- 利用重定位寄存器（基址寄存器）、界地址寄存器（限长寄存器）进行越界检查；重定位寄存器存放物理基地址，界地址寄存器存放**最大逻辑地址**。进程的指令要访问某个地址A小于界地址时，允许访问，访问的实际物理地址为A+基址

